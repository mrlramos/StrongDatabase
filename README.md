# StrongDatabase

Projeto didÃ¡tico e moderno demonstrando arquitetura distribuÃ­da com .NET 8, PostgreSQL e Docker Compose, com replicaÃ§Ã£o real, failover, e balanceamento.

---

## Tecnologias Utilizadas
- **.NET 8 (ASP.NET Core Web API)**
- **PostgreSQL 16** (Primary, Standby, Replica1, Replica2)
- **Docker Compose**

---

## Estrutura de Pastas
```
StrongDatabase/
â”‚
â”œâ”€â”€ StrongDatabase.Api/         # CÃ³digo-fonte da aplicaÃ§Ã£o .NET
â”œâ”€â”€ docker/                       # ConfiguraÃ§Ãµes e scripts dos bancos
â”‚   â”œâ”€â”€ primary/                  # Config do banco primÃ¡rio
â”‚   â”œâ”€â”€ standby/                  # Config do standby (sÃ­ncrono)
â”‚   â”œâ”€â”€ replica1/                 # Config da rÃ©plica 1 (assÃ­ncrona)
â”‚   â””â”€â”€ replica2/                 # Config da rÃ©plica 2 (assÃ­ncrona)
â”œâ”€â”€ scripts/                      # Scripts SQL de criaÃ§Ã£o dos bancos e dados
â”œâ”€â”€ docker-compose.yml            # OrquestraÃ§Ã£o dos containers
â””â”€â”€ README.md                     # DocumentaÃ§Ã£o
```

---

## Objetivo do Projeto
- Demonstrar **arquitetura de bancos distribuÃ­dos** com replicaÃ§Ã£o real (sÃ­ncrona e assÃ­ncrona)
- **Failover automÃ¡tico** e seguro (zero perda de dados)
- **Leitura distribuÃ­da** entre rÃ©plicas
- **Balanceamento inteligente** de conexÃµes na aplicaÃ§Ã£o
- **Health checks** e monitoramento
- **Exemplo prÃ¡tico** de integraÃ§Ã£o .NET + PostgreSQL + Docker Compose

---

## Arquitetura e Fluxo

### 1. **Containers e FunÃ§Ãµes**
- **primary-db**: Banco principal (escrita e leitura de emergÃªncia)
- **standby-db**: Standby sÃ­ncrono (failover, nunca perde dados)
- **replica1-db/replica2-db**: RÃ©plicas assÃ­ncronas (leitura distribuÃ­da)
- **strongdatabase-api**: API .NET 8, faz balanceamento e failover automÃ¡tico

### 2. **ReplicaÃ§Ã£o e Failover**
- O **primÃ¡rio** replica via WAL para standby (sÃ­ncrono) e rÃ©plicas (assÃ­ncronas)
- O **standby** sÃ³ confirma a escrita quando recebe o dado (garante zero perda)
- As **rÃ©plicas** recebem as alteraÃ§Ãµes de forma assÃ­ncrona (podem atrasar alguns segundos)
- Se o primÃ¡rio cair, a aplicaÃ§Ã£o redireciona escritas para o standby
- Se todas as rÃ©plicas e o primÃ¡rio caÃ­rem, leituras vÃ£o para o standby

#### ðŸ”Ž Como funciona a sincronizaÃ§Ã£o sÃ­ncrona no PostgreSQL

A sincronizaÃ§Ã£o sÃ­ncrona em bancos de dados, como no PostgreSQL, garante que os dados escritos no banco primÃ¡rio sejam replicados para o banco standby antes de confirmar a transaÃ§Ã£o ao cliente. Isso assegura zero perda de dados em caso de falha do primÃ¡rio.

**Como funciona:**
- **Escrita no primÃ¡rio:** Quando uma transaÃ§Ã£o (INSERT, UPDATE, DELETE) Ã© executada no banco primÃ¡rio, os dados sÃ£o registrados no WAL (Write-Ahead Log), um log de transaÃ§Ãµes.
- **Envio ao standby:** O WAL Ã© enviado ao banco standby em tempo real via streaming replication.
- **ConfirmaÃ§Ã£o sÃ­ncrona:** O primÃ¡rio aguarda a confirmaÃ§Ã£o do standby de que os dados do WAL foram recebidos e aplicados (ou pelo menos gravados em disco, dependendo da configuraÃ§Ã£o).
- **Commit no primÃ¡rio:** Somente apÃ³s a confirmaÃ§Ã£o do standby, o primÃ¡rio confirma a transaÃ§Ã£o ao cliente.
- **Failover seguro:** Se o primÃ¡rio falhar, o standby jÃ¡ tem todos os dados confirmados, permitindo assumir como novo primÃ¡rio sem perda.

**OperaÃ§Ãµes nos bastidores:**
- **WAL Streaming:** O primÃ¡rio envia os registros do WAL para o standby por uma conexÃ£o TCP (via wal_sender no primÃ¡rio e wal_receiver no standby).
- **Synchronous Commit:** Configurado com `synchronous_commit = on` e `synchronous_standby_names` no postgresql.conf do primÃ¡rio, especificando o standby.
- **Handshaking:** O standby confirma a recepÃ§Ã£o/aplicaÃ§Ã£o do WAL, e o primÃ¡rio aguarda essa resposta antes de prosseguir.
- **LatÃªncia:** Como o primÃ¡rio espera a confirmaÃ§Ã£o, hÃ¡ um pequeno aumento na latÃªncia das transaÃ§Ãµes, mas isso garante consistÃªncia.

**ConfiguraÃ§Ã£o tÃ­pica (PostgreSQL):**
```conf
# postgresql.conf (primÃ¡rio)
wal_level = replica
synchronous_commit = on
synchronous_standby_names = 'standby-db'
max_wal_senders = 10
```

**Trade-offs:**
- **Vantagem:** Zero perda de dados, ideal para sistemas crÃ­ticos.
- **Desvantagem:** Maior latÃªncia, pois o primÃ¡rio aguarda o standby.

> **Resumindo:**
> A sincronizaÃ§Ã£o sÃ­ncrona usa o WAL para replicar dados em tempo real, aguardando confirmaÃ§Ã£o do standby antes de commit, garantindo consistÃªncia total.

#### ðŸ”Ž Como funciona a replicaÃ§Ã£o assÃ­ncrona no PostgreSQL

A replicaÃ§Ã£o assÃ­ncrona no PostgreSQL permite que rÃ©plicas (read replicas) recebam atualizaÃ§Ãµes do banco primÃ¡rio sem bloquear as transaÃ§Ãµes, otimizando leituras distribuÃ­das, mas com possÃ­vel atraso nos dados.

**Como funciona:**
- **Escrita no primÃ¡rio:** TransaÃ§Ãµes (INSERT, UPDATE, DELETE) sÃ£o gravadas no WAL (Write-Ahead Log) do banco primÃ¡rio.
- **Envio ao rÃ©plica:** O WAL Ã© enviado Ã s rÃ©plicas via streaming replication, mas sem esperar confirmaÃ§Ã£o.
- **AplicaÃ§Ã£o na rÃ©plica:** As rÃ©plicas aplicam os registros do WAL de forma independente, o que pode causar um pequeno atraso (eventual consistency).
- **Leituras nas rÃ©plicas:** As rÃ©plicas (hot standby) atendem consultas de leitura, aliviando o primÃ¡rio e escalando a performance de leitura.

**OperaÃ§Ãµes nos bastidores:**
- **WAL Streaming:** O primÃ¡rio envia o WAL Ã s rÃ©plicas via wal_sender (primÃ¡rio) e wal_receiver (rÃ©plica).
- **AssÃ­ncrono:** O primÃ¡rio confirma a transaÃ§Ã£o ao cliente sem aguardar as rÃ©plicas, reduzindo latÃªncia.
- **Hot Standby:** RÃ©plicas podem processar consultas de leitura enquanto aplicam o WAL, configurado com hot_standby = on.
- **Atraso:** Dependendo da carga ou rede, rÃ©plicas podem estar alguns segundos atrÃ¡s do primÃ¡rio.

**ConfiguraÃ§Ã£o tÃ­pica (PostgreSQL):**
```conf
# postgresql.conf (primÃ¡rio)
wal_level = replica
max_wal_senders = 10
hot_standby = on  # (nas rÃ©plicas)
```

**Trade-offs:**
- **Vantagem:** Menor latÃªncia para escritas, alta escalabilidade para leituras.
- **Desvantagem:** RÃ©plicas podem ter dados ligeiramente desatualizados (atraso de milissegundos a segundos).

> **Resumindo:**
> A replicaÃ§Ã£o assÃ­ncrona usa o WAL para enviar dados Ã s rÃ©plicas sem bloquear o primÃ¡rio, ideal para escalar leituras, mas com consistÃªncia eventual.

### 3. **Balanceamento Inteligente (DbContextRouter)**
- **Escrita:** Sempre tenta o primÃ¡rio, se falhar, usa o standby
- **Leitura:** Distribui entre as rÃ©plicas, se todas falharem tenta o primÃ¡rio, se falhar, standby
- **Logs informativos** mostram cada fallback e decisÃ£o

### 4. **Health Checks**
- Endpoint `/health` monitora API e conexÃ£o com banco
- Pode ser usado por orquestradores ou load balancers externos

---

## Modelo de Dados

### Tabelas
- **Cliente**: `id`, `nome`, `email`
- **Produto**: `id`, `nome`, `preco`
- **Compra**: `id`, `cliente_id`, `produto_id`, `quantidade`, `data_compra`

### Exemplo de Dados
```sql
INSERT INTO cliente (nome, email) VALUES
  ('JoÃ£o Silva', 'joao@email.com'),
  ('Maria Souza', 'maria@email.com');
INSERT INTO produto (nome, preco) VALUES
  ('Notebook', 3500.00),
  ('Mouse', 80.00);
INSERT INTO compra (cliente_id, produto_id, quantidade) VALUES
  (1, 1, 1),
  (2, 2, 2);
```

---

## Endpoints DisponÃ­veis

### Clientes (`/api/cliente`)
- `GET /api/cliente` â€” Lista todos os clientes
- `GET /api/cliente/{id}` â€” Busca cliente por ID
- `POST /api/cliente` â€” Cria novo cliente
- `PUT /api/cliente/{id}` â€” Atualiza cliente
- `DELETE /api/cliente/{id}` â€” Remove cliente

### Produtos (`/api/produto`)
- `GET /api/produto` â€” Lista todos os produtos
- `GET /api/produto/{id}` â€” Busca produto por ID
- `POST /api/produto` â€” Cria novo produto
- `PUT /api/produto/{id}` â€” Atualiza produto
- `DELETE /api/produto/{id}` â€” Remove produto

### Compras (`/api/compra`)
- `GET /api/compra` â€” Lista todas as compras
- `GET /api/compra/{id}` â€” Busca compra por ID (inclui cliente e produto)
- `POST /api/compra` â€” Cria nova compra
- `PUT /api/compra/{id}` â€” Atualiza compra
- `DELETE /api/compra/{id}` â€” Remove compra

### Health Check e Monitoramento
- `GET /health` â€” Health check detalhado com status de todos os servidores de banco
- `GET /api/health` â€” Health check via controller com informaÃ§Ãµes organizadas
- `GET /api/health/simple` â€” VerificaÃ§Ã£o rÃ¡pida do status da API
- `GET /api/health/version` â€” InformaÃ§Ãµes detalhadas sobre versÃ£o e ambiente

#### Exemplo de Resposta do Health Check (`/health`)
```json
{
  "status": "healthy",
  "totalDuration": 45.23,
  "results": {
    "database_health_check": {
      "status": "healthy",
      "description": "Todos os serviÃ§os estÃ£o funcionando corretamente",
      "duration": "44.15ms",
      "data": {
        "api": {
          "status": "healthy",
          "version": "1.0.0",
          "environment": "Development",
          "uptime": "00.02:15:30",
          "startTime": "2024-01-15T10:30:00Z",
          "timestamp": "2024-01-15T12:45:30Z"
        },
        "primary": {
          "status": "healthy",
          "responseTimeMs": 12,
          "databaseName": "strongdatabase_primary",
          "user": "primary_user",
          "serverAddress": "172.18.0.2",
          "serverPort": 5432,
          "postgresqlVersion": "16.1",
          "lastCheck": "2024-01-15T12:45:30Z"
        },
        "standby": {
          "status": "healthy",
          "responseTimeMs": 15,
          "databaseName": "strongdatabase_standby",
          "user": "standby_user",
          "serverAddress": "172.18.0.3",
          "serverPort": 5432,
          "postgresqlVersion": "16.1",
          "lastCheck": "2024-01-15T12:45:30Z"
        },
        "replica1": {
          "status": "healthy",
          "responseTimeMs": 8,
          "databaseName": "strongdatabase_replica1",
          "user": "replica1_user",
          "serverAddress": "172.18.0.4",
          "serverPort": 5432,
          "postgresqlVersion": "16.1",
          "lastCheck": "2024-01-15T12:45:30Z"
        },
        "replica2": {
          "status": "healthy",
          "responseTimeMs": 10,
          "databaseName": "strongdatabase_replica2",
          "user": "replica2_user",
          "serverAddress": "172.18.0.5",
          "serverPort": 5432,
          "postgresqlVersion": "16.1",
          "lastCheck": "2024-01-15T12:45:30Z"
        },
        "totalCheckDurationMs": 45
      }
    }
  }
}
```

---

## Como Rodar o Projeto

1. **Suba os containers:**
   ```sh
   docker-compose up --build -d
   ```
2. **Acesse a API:**
   - [http://localhost:5000/swagger](http://localhost:5000/swagger) (interface interativa)
   - Ou use os endpoints REST diretamente

---

## Detalhes TÃ©cnicos e Scripts

### ConfiguraÃ§Ã£o do PrimÃ¡rio (`docker/primary/postgresql.conf`)
```conf
listen_addresses = '*'
wal_level = replica
max_wal_senders = 10
wal_keep_size = 64
archive_mode = on
archive_command = 'cd .'
hot_standby = on
synchronous_standby_names = 'standby-db'
```

### Standby SÃ­ncrono (`docker/standby/standby-entrypoint.sh`)
- Clona dados do primÃ¡rio ao iniciar
- Conecta como standby sÃ­ncrono
- SÃ³ confirma escrita quando recebe o dado

### RÃ©plicas AssÃ­ncronas (`docker/replica1/replica-entrypoint.sh`)
- Clonam dados do primÃ¡rio ao iniciar
- Operam como hot standby assÃ­ncrono

### OrquestraÃ§Ã£o Docker Compose
- Cada banco expÃµe uma porta diferente (`5433`, `5434`, `5435`, `5436`)
- API exposta em `5000`
- Volumes montam scripts e configs customizados
- DependÃªncias garantem ordem de inicializaÃ§Ã£o

---

## Fluxo de Balanceamento e Failover (DidÃ¡tico)

1. **Leitura**
   - API tenta ler nas rÃ©plicas (round-robin)
   - Se todas falharem, tenta o primÃ¡rio
   - Se primÃ¡rio falhar, tenta o standby
2. **Escrita**
   - API sempre tenta o primÃ¡rio
   - Se primÃ¡rio falhar, usa o standby
3. **Failover**
   - Se o primÃ¡rio cair, standby assume sem perda de dados
   - RÃ©plicas podem ficar alguns segundos atrÃ¡s (eventual consistency)

---

## Exemplos de Teste

### Testar Health Check
```sh
# Health check detalhado (endpoint principal)
curl http://localhost:5000/health

# Health check via controller
curl http://localhost:5000/api/health

# VerificaÃ§Ã£o rÃ¡pida da API
curl http://localhost:5000/api/health/simple

# InformaÃ§Ãµes de versÃ£o
curl http://localhost:5000/api/health/version
```

### Listar Clientes
```sh
curl http://localhost:5000/api/cliente
```

### Criar Cliente
```sh
curl -X POST http://localhost:5000/api/cliente -H "Content-Type: application/json" -d '{"nome":"Novo Cliente","email":"novo@email.com"}'
```

### Simular Failover
1. Pare o primÃ¡rio:
   ```sh
   docker stop primary-db
   ```
2. Teste o health check para ver o status dos servidores:
   ```sh
   curl http://localhost:5000/health
   ```
3. FaÃ§a uma escrita (POST): a API irÃ¡ redirecionar para o standby automaticamente.
4. Logs mostrarÃ£o o fallback.

---

## ObservaÃ§Ãµes DidÃ¡ticas
- **Standby sÃ­ncrono** garante zero perda de dados
- **Read replicas** aumentam performance de leitura
- **Balanceamento e failover** sÃ£o automÃ¡ticos e transparentes para o usuÃ¡rio
- **Arquitetura pronta para produÃ§Ã£o** (com adaptaÃ§Ãµes de seguranÃ§a e monitoramento)

---

## CrÃ©ditos e ReferÃªncias
- Projeto didÃ¡tico inspirado nas melhores prÃ¡ticas de arquitetura distribuÃ­da
- DocumentaÃ§Ã£o oficial: [PostgreSQL Streaming Replication](https://www.postgresql.org/docs/current/warm-standby.html)
- [ASP.NET Core Docs](https://learn.microsoft.com/aspnet/core)

---

## Como Limpar o Projeto

Para manter o projeto limpo e sem arquivos desnecessÃ¡rios, remova as seguintes pastas sempre que quiser:

- `StrongDatabase.Api/bin/`
- `StrongDatabase.Api/obj/`
- `.vs/` (cache do Visual Studio, pode estar em uso â€” feche o Visual Studio para apagar tudo)

Essas pastas sÃ£o geradas automaticamente durante o build e podem ser excluÃ­das sem risco. O comando para Windows PowerShell Ã©:

```powershell
Remove-Item -Recurse -Force .\StrongDatabase.Api\bin
Remove-Item -Recurse -Force .\StrongDatabase.Api\obj
Remove-Item -Recurse -Force .\.vs
```

No Linux/Mac:
```bash
rm -rf StrongDatabase.Api/bin StrongDatabase.Api/obj .vs
```

> **Dica:** Antes de subir para o Git, sempre limpe o projeto para evitar arquivos desnecessÃ¡rios no repositÃ³rio!

Essas prÃ¡ticas ajudam a manter o repositÃ³rio enxuto e organizado.

---

## Subindo o ambiente do zero (apÃ³s limpar tudo no Docker)

Sempre que vocÃª limpar todos os containers, volumes e imagens no Docker Desktop, siga este fluxo para garantir que a replicaÃ§Ã£o funcione:

1. Suba normalmente:
   ```sh
   docker-compose up --build -d
   ```
   (Espere todos os containers subirem. As rÃ©plicas e standby podem parar na primeira tentativa, isso Ã© esperado.)

2. Execute o script pÃ³s-up para ajustar a replicaÃ§Ã£o:
   - **No Windows:**
     ```sh
     scripts\pos-up-windows.bat
     ```
   - **No Linux/Mac:**
     ```sh
     bash scripts/pos-up-linux.sh
     ```

Esses scripts vÃ£o:
- Copiar o `pg_hba.conf` customizado para dentro do primary-db
- Reiniciar o primary-db
- Reiniciar as rÃ©plicas e standby para garantir a replicaÃ§Ã£o

Pronto! O ambiente estarÃ¡ normalizado e funcional.

---

**DÃºvidas, sugestÃµes ou quer expandir? Fique Ã  vontade para contribuir!** 