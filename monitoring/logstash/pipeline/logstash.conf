input {
  beats {
    port => 5044
  }
  
  # Direct input from .NET Serilog
  tcp {
    port => 5000
    codec => json_lines
    tags => ["serilog", "api"]
  }
}

filter {
  # Parse container logs from Docker
  if [container][name] {
    mutate {
      add_field => { "service_name" => "%{[container][name]}" }
    }
  }

  # Handle Serilog structured logs
  if "serilog" in [tags] {
    # Already in JSON format, just enrich
    mutate {
      add_field => { "log_type" => "application" }
    }
  }

  # Parse PostgreSQL logs
  if [service_name] =~ /.*-db$/ {
    mutate {
      add_field => { "log_type" => "database" }
    }
    
    # Parse PostgreSQL log format
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:pid}\] %{WORD:log_level}:  %{GREEDYDATA:pg_message}"
      }
      tag_on_failure => ["_grokparsefailure_postgresql"]
    }
  }

  # Parse API logs
  if [service_name] == "strongdatabase-api" {
    mutate {
      add_field => { "log_type" => "application" }
    }
  }

  # Add common fields
  mutate {
    add_field => { 
      "environment" => "development"
      "system" => "strongdatabase"
      "processed_at" => "%{@timestamp}"
    }
  }

  # Parse JSON logs if they're not already parsed
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }
    
    # Move parsed fields to root level for better querying
    if [parsed] {
      ruby {
        code => "
          parsed = event.get('parsed')
          if parsed.is_a?(Hash)
            parsed.each { |key, value| event.set(key, value) }
          end
          event.remove('parsed')
        "
      }
    }
  }

  # Convert log levels to standard format
  if [level] {
    mutate {
      lowercase => [ "level" ]
    }
  }

  # Add correlation tracking
  if ![correlation_id] and [RequestId] {
    mutate {
      add_field => { "correlation_id" => "%{RequestId}" }
    }
  }

  # Geo IP enrichment for external requests (if needed)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    
    # Dynamic index based on log type and date
    index => "strongdatabase-%{log_type}-%{+YYYY.MM.dd}"
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
} 